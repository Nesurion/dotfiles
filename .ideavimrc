"source ~/.idea-lazy.vim
source ~/.vimrc

" WhichKey
set which-key
" disable the timeout option
set notimeout
" increase the timeoutlen (default: 1000), don't add space around the equal sign

set easymotion
" set mini around inside
set mini-ai

" Multiple cursors
set multiple-cursors
nmap <C-n> <Plug>NextWholeOccurrence
xmap <C-n> <Plug>NextWholeOccurrence
"xmap <C-x> <Plug>SkipOccurrence
"xmap <C-p> <Plug>RemoveOccurrence
nmap <leader><C-n> <Plug>AllWholeOccurrences
xmap <leader><C-n> <Plug>AllWholeOccurrences
nmap <C-j> <Action>(EditorCloneCaretBelow)
nmap <C-k> <Action>(EditorCloneCaretAbove)
xmap <C-j> <Action>(EditorCloneCaretBelow)
xmap <C-k> <Action>(EditorCloneCaretAbove)

" set ideajoin
set ideajoin
" https://plugins.jetbrains.com/plugin/25897-vim-functiontextobj
set functiontextobj

" Sneak
"" Use sneak single char to replace f and t
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T

" sort which key hints none case sensitive (otherwise capital letters are first)
let g:WhichKey_SortCaseSensitive = "false"

let g:WhichKey_split_horizontal = "<leader>- Split horizontal"
let g:WhichKey_split_vertical = "<leader><Bslash> Split vertical"

""" IdeaVim Keymap
"" Move lines
" Move Down
nmap <A-j> <Action>(MoveLineDown)
" Move Up
nmap <A-k> <Action>(MoveLineUp)

"" Camel case movement
map E ]w
map B [b

"" Buffer navigation
let g:WhichKeyDesc_buffer = "<leader>b +buffer"
" Prev Buffer
nmap <S-h> <Action>(PreviousTab)
" Next Buffer
nmap <S-l> <Action>(NextTab)
" Split Buffer vertical
let g:WhichKeyDesc_buffer_split = "<leader>bs Split Buffer"
nmap <leader>bs :vsplit<CR>
" Delete Buffer
let g:WhichKeyDesc_buffer_close = "<leader>bd Close Buffer"
nmap <leader>bd <Action>(CloseContent)
nmap <C-w> <Action>(CloseContent)
" Close other buffers
let g:WhichKeyDesc_buffer_close_other = "<leader>bo Close Other Buffers"
nmap <leader>bo <Action>(CloseAllEditorsButActive)
" Move tab to next group
let g:WhichKeyDesc_tab_move_to_next_group = "<leader>bg Move tab to next group"
nmap <leader>bg <Action>(MoveEditorToOppositeTabGroup)
" Move focus to next tab group
let g:WhichKeyDesc_tab_next_group = "<leader>bn Move focus to next tab group"
nmap <leader>bn <Action>(NextSplitter)


"" Error navigation
" Next Error
nmap ]] <Action>(GotoNextError)
" Prev Error
nmap [[ <Action>(GotoPreviousError)

" Signature Help in Insert Mode
imap <C-k> <C-o><Action>(ParameterInfo)i
nmap <C-k> <Action>(ParameterInfo)

"" GitHub <leader>gh
let g:WhichKeyDesc_git = "<leader>gh +github"
" Git Blame Line
let g:WhichKeyDesc_git_blame = "<leader>ghb git blame"
nmap <leader>ghb <Action>(Annotate)
let g:WhichKeyDesc_git_pr = "<leader>ghp Pull Requests"
nmap <leader>ghp <Action>(ActivatePullRequestsToolWindow)

"" Goto
let g:WhichKeyDesc_goto = "g +goto"
" Goto Definition
let g:WhichKeyDesc_goto_declaration = "gd Goto Declaration"
nmap gd <Action>(GotoDeclaration)
" References
let g:WhichKeyDesc_goto_usage = "gu Find Usage"
nmap gu <Action>(FindUsages)
" Goto Implementation
let g:WhichKeyDesc_goto_implementation = "gi Goto Implementation"
nmap gi <Action>(GotoImplementation)
" Goto Type Definition
let g:WhichKeyDesc_goto_type_definition = "gy Goto Type Definition"
nmap gy <Action>(GotoTypeDeclaration)
" Goto Test
let g:WhichKeyDesc_goto_test = "gt Goto Test"
map gt <Action>(GotoTest)
" Goto Class
let g:WhichKeyDesc_goto_class = "gC Goto Class"
map gC ?class <CR>:nohlsearch<CR>w
" Goto Function
let g:WhichKeyDesc_goto_function = "gf Goto Function"
map gf ?fun <CR>:nohlsearch<CR>w

"" Code <leader>c
let g:WhichKeyDesc_code = "<leader>c +code"
" Rename File
let g:WhichKeyDesc_code_rename_file = "<leader>cR Rename File"
nmap <leader>cR <Action>(RenameFile)
" Rename
let g:WhichKeyDesc_code_rename = "<leader>cr Rename"
nmap <leader>cr <Action>(RenameElement)
" Build Project
let g:WhichKeyDesc_code_build = "<leader>cb Build"
nmap <leader>cb <Action>(CompileDirty)
" Source Action
let g:WhichKeyDesc_code_action = "<leader>cA Action"
nmap <leader>cA <Action>(ShowIntentionActions)
" Optimize Imports
let g:WhichKeyDesc_code_optimize_imports = "<leader>co Optimize Imports"
map <leader>co <Action>(OptimizeImports)
" Collapse
let g:WhichKeyDesc_collapse = "<cr> Collapse"
map <cr> <Action>(ExpandCollapseToggleAction)
let g:WhichKeyDesc_collapse_all = "zM Collapse all"
map zM <Action>(CollapseAllRegions)
let g:WhichKeyDesc_expand_all = "zR Expand all"
map zR <Action>(ExpandAllRegions)

let g:WhichKeyDesc_code_format = "== Code Format"
map == <Action>(ReformatCode)

"" Project View
" Focus Project View
let g:WhichKeyDesc_explorer_focus = "<leader>e Project View"
nmap <leader>e <Action>(ActivateProjectToolWindow)
" Select in Project View
let g:WhichKeyDesc_explorer_select = "<leader>E Select in Project View"
nmap <leader>E <Action>(SelectInProjectView)

"" Code Navigation
" Find Files (Root Dir)
let g:WhichKeyDesc_find_file = "<leader><space> Select in Project View"
nmap <leader><space> <Action>(GotoFile)
" Switch Buffer
let g:WhichKeyDesc_switcher_focus = "<leader>, Switch"
nmap <leader>, <Action>(Switcher)
" Grep (Root Dir)
nmap <leader>/ <Action>(FindInPath)
" Command History
nmap <leader>: <Action>(ShowCommands)

"" Debug
let g:WhichKeyDesc_debug = "<leader>d +debug"
" " Toggle Breakpoint
let g:WhichKeyDesc_debug_breakpoint = "<leader>db Toggle Breakpoint"
nmap <leader>db <Action>(ToggleLineBreakpoint)

"" Tests
let g:WhichKeyDesc_tests = "<leader>t +tests"
" Run File
let g:WhichKeyDesc_tests_run = "<leader>tt Run Test"
nmap <leader>tt <Action>(RunClass)
" Rerun Last
let g:WhichKeyDesc_tests_rerun = "<leader>tr Rerun Last"
nmap <leader>tr <Action>(Rerun)
" Debug
let g:WhichKeyDesc_tests_debug = "<leader>td Debug Test"
nmap <leader>td <Action>(ContextDebug)
" Evaluate Expression
let g:WhichKeyDesc_tests_eval_expression = "<leader>te Evaluate Expression"
nmap <leader>te <Action>(EvaluateExpression)
" Stop
let g:WhichKeyDesc_tests_stop = "<leader>tS Stop"
nmap <leader>tS <Action>(Stop)

"" Window
let g:WhichKeyDesc_window = "<leader>w +window"
" Debug
let g:WhichKeyDesc_window_debug = "<leader>wd Debug"
nmap <leader>wd <Action>(ActivateDebugToolWindow)
" Build
let g:WhichKeyDesc_window_build = "<leader>wb Build"
nmap <leader>wb <Action>(ActivateBuildToolWindow)
" Run
let g:WhichKeyDesc_window_run = "<leader>wr Run"
nmap <leader>wr <Action>(ActivateRunToolWindow)
" GitHub Copilot Chat
let g:WhichKeyDesc_window_gh_copilot_chat = "<leader>wc Copilot Chat"
nmap <leader>wc <Action>(ActivateGitHubCopilotChatToolWindow)
" Pull Requests
let g:WhichKeyDesc_window_pr = "<leader>wp Pull Requests"
nmap <leader>wp <Action>(ActivatePullRequestsToolWindow)

"" Invert word under cursor
function! Invert()
  let antonyms = ['true', 'false',
                 \'True', 'False',
                 \'==', '!=',]

  normal "wyiw
  let wordUnderCaret = @w

  let eraseWord = 'ciw'
  let count = 0
  while (count < len(antonyms))
    if (antonyms[count] ==# wordUnderCaret)
      let antonym = (count % 2 ==? 0) ? antonyms[count + 1] : antonyms[count - 1]
      execute 'normal ' .. eraseWord .. antonym
      break
    endif
    let count += 1
  endwhile
endfunction

let g:WhichKeyDesc_invert_word = "<leader>i Invert word"
nnoremap <leader>i :call Invert()<CR>i<ESC>

""" -- map ide actions to ideavim -- https://jb.gg/abva4t
"map <leader><leader> <Action>(GotoFile)
" map gd <Action>(GotoDeclaration)
" map <leader>tt <Action>(RunClass)
"map gcc <Action>(CommentByLineComment)
"" Window splits
"map <leader>wv <Action>(SplitVertically)
"map <leader>ws <Action>(SplitHorizontally)
"map <leader>wu <Action>(Unsplit)
"map <leader>wm <Action>(MoveEditorToOppositeTabGroup)
